# ETF合约交互指南

## 🎯 快速开始

### 环境准备
```bash
# 1. 克隆项目
git clone <repository_url>
cd contracts

# 2. 安装依赖
forge install

# 3. 设置环境变量
export PRIVATE_KEY="your_private_key"
export SEPOLIA_RPC_URL="https://sepolia.infura.io/v3/your_project_id"
```

## 📝 合约ABI接口

### ETFv1 核心接口
```solidity
interface IETF {
    // 铸造ETF代币
    function mint(uint256[] calldata amounts) external;
    
    // 赎回ETF代币
    function redeem(uint256 shares) external;
    
    // 查询成分代币
    function getTokens() external view returns (address[] memory);
    
    // 查询每份额对应的代币数量
    function getTokenAmounts() external view returns (uint256[] memory);
    
    // 查询最小铸造数量
    function minMintAmount() external view returns (uint256);
}
```

### ETFv2 增强接口
```solidity
interface IETFv2 {
    // ETH投资
    function investWithETH() external payable;
    
    // ETH赎回
    function redeemToETH(uint256 shares) external;
    
    // 查询Uniswap路由
    function swapRouter() external view returns (address);
}
```

## 🔧 JavaScript交互示例

### 连接合约
```javascript
const { ethers } = require('ethers');

// 连接到Sepolia网络
const provider = new ethers.JsonRpcProvider('https://sepolia.infura.io/v3/your_project_id');
const wallet = new ethers.Wallet('your_private_key', provider);

// ETFv1合约实例
const ETFv1_ADDRESS = '0x37Ee135db8e41D3F9C15F97918C58651E8A564A6';
const ETFv1_ABI = [...]; // 从编译结果获取ABI
const etfv1 = new ethers.Contract(ETFv1_ADDRESS, ETFv1_ABI, wallet);
```

### ETFv1 交互
```javascript
// 1. 查询合约信息
async function getETFInfo() {
    const name = await etfv1.name();
    const symbol = await etfv1.symbol();
    const tokens = await etfv1.getTokens();
    const amounts = await etfv1.getTokenAmounts();
    
    console.log(`ETF: ${name} (${symbol})`);
    console.log('成分代币:', tokens);
    console.log('代币数量:', amounts.map(a => ethers.formatEther(a)));
}

// 2. 投资ETF
async function investETF() {
    const tokenAddresses = await etfv1.getTokens();
    const tokenAmounts = await etfv1.getTokenAmounts();
    
    // 批准代币转账
    for (let i = 0; i < tokenAddresses.length; i++) {
        const token = new ethers.Contract(tokenAddresses[i], ERC20_ABI, wallet);
        const approveTx = await token.approve(ETFv1_ADDRESS, tokenAmounts[i]);
        await approveTx.wait();
        console.log(`已批准 ${tokenAddresses[i]} 转账`);
    }
    
    // 铸造ETF
    const mintTx = await etfv1.mint(tokenAmounts);
    const receipt = await mintTx.wait();
    console.log('投资成功:', receipt.transactionHash);
}

// 3. 赎回ETF
async function redeemETF(shares) {
    const redeemTx = await etfv1.redeem(ethers.parseEther(shares));
    const receipt = await redeemTx.wait();
    console.log('赎回成功:', receipt.transactionHash);
}
```

### ETFv2 ETH投资
```javascript
const ETFv2_ADDRESS = '0xe75dDeb4d90F62b0D70CAFe2c8db9B968E29336c';
const etfv2 = new ethers.Contract(ETFv2_ADDRESS, ETFv2_ABI, wallet);

// ETH投资
async function investWithETH() {
    const investAmount = ethers.parseEther('0.1'); // 0.1 ETH
    
    const tx = await etfv2.investWithETH({
        value: investAmount
    });
    
    const receipt = await tx.wait();
    console.log('ETH投资成功:', receipt.transactionHash);
}

// ETH赎回
async function redeemToETH(shares) {
    const tx = await etfv2.redeemToETH(ethers.parseEther(shares));
    const receipt = await tx.wait();
    console.log('ETH赎回成功:', receipt.transactionHash);
}
```

## 🐍 Python交互示例

### 环境设置
```python
from web3 import Web3
import json

# 连接到Sepolia网络
w3 = Web3(Web3.HTTPProvider('https://sepolia.infura.io/v3/your_project_id'))

# 设置账户
account = w3.eth.account.from_key('your_private_key')
w3.eth.default_account = account.address

# 合约地址和ABI
ETF_V1_ADDRESS = '0x37Ee135db8e41D3F9C15F97918C58651E8A564A6'
with open('out/ETFv1.sol/ETFv1.json', 'r') as f:
    contract_json = json.load(f)
    ETF_ABI = contract_json['abi']

# 创建合约实例
etf_contract = w3.eth.contract(address=ETF_V1_ADDRESS, abi=ETF_ABI)
```

### 合约交互
```python
# 查询合约信息
def get_etf_info():
    name = etf_contract.functions.name().call()
    symbol = etf_contract.functions.symbol().call()
    tokens = etf_contract.functions.getTokens().call()
    amounts = etf_contract.functions.getTokenAmounts().call()
    
    print(f"ETF: {name} ({symbol})")
    print(f"成分代币: {tokens}")
    print(f"代币数量: {[Web3.from_wei(amt, 'ether') for amt in amounts]}")

# 投资ETF
def invest_etf():
    tokens = etf_contract.functions.getTokens().call()
    amounts = etf_contract.functions.getTokenAmounts().call()
    
    # 批准代币转账
    erc20_abi = [...]  # ERC20 ABI
    for i, token_addr in enumerate(tokens):
        token_contract = w3.eth.contract(address=token_addr, abi=erc20_abi)
        
        # 构建交易
        approve_txn = token_contract.functions.approve(
            ETF_V1_ADDRESS, amounts[i]
        ).build_transaction({
            'from': account.address,
            'nonce': w3.eth.get_transaction_count(account.address),
            'gas': 100000,
            'gasPrice': w3.to_wei('20', 'gwei')
        })
        
        # 签名并发送
        signed_approve = w3.eth.account.sign_transaction(approve_txn, account.key)
        approve_hash = w3.eth.send_raw_transaction(signed_approve.rawTransaction)
        w3.eth.wait_for_transaction_receipt(approve_hash)
        print(f"已批准代币 {token_addr}")
    
    # 铸造ETF
    mint_txn = etf_contract.functions.mint(amounts).build_transaction({
        'from': account.address,
        'nonce': w3.eth.get_transaction_count(account.address),
        'gas': 500000,
        'gasPrice': w3.to_wei('20', 'gwei')
    })
    
    signed_mint = w3.eth.account.sign_transaction(mint_txn, account.key)
    mint_hash = w3.eth.send_raw_transaction(signed_mint.rawTransaction)
    receipt = w3.eth.wait_for_transaction_receipt(mint_hash)
    print(f"投资成功: {receipt.transactionHash.hex()}")
```

## 📊 事件监听

### JavaScript事件监听
```javascript
// 监听铸造事件
etfv1.on('Transfer', (from, to, value) => {
    if (from === ethers.ZeroAddress) {
        console.log(`新铸造: ${ethers.formatEther(value)} ETF 代币给 ${to}`);
    }
});

// 监听投资事件
etfv1.on('Invested', (user, amounts, shares) => {
    console.log(`用户 ${user} 投资了:`);
    amounts.forEach((amt, i) => {
        console.log(`  代币${i}: ${ethers.formatEther(amt)}`);
    });
    console.log(`获得份额: ${ethers.formatEther(shares)}`);
});
```

### Python事件监听
```python
# 监听新区块中的事件
def watch_events():
    # 创建事件过滤器
    event_filter = etf_contract.events.Invested.create_filter(fromBlock='latest')
    
    while True:
        for event in event_filter.get_new_entries():
            print(f"投资事件: {event}")
            print(f"用户: {event.args.user}")
            print(f"投资金额: {[Web3.from_wei(amt, 'ether') for amt in event.args.amounts]}")
            print(f"获得份额: {Web3.from_wei(event.args.shares, 'ether')}")
        
        time.sleep(2)  # 每2秒检查一次
```

## 🧪 单元测试示例

### Foundry测试
```solidity
// test/ETFv1.t.sol
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "../src/ETFv1/ETFv1.sol";
import "../src/MockToken/MockToken.sol";

contract ETFv1Test is Test {
    ETFv1 public etf;
    MockToken public token1;
    MockToken public token2;
    MockToken public token3;
    
    address[] public tokens;
    uint256[] public amounts;
    
    function setUp() public {
        // 部署测试代币
        token1 = new MockToken("Token1", "TK1", 18);
        token2 = new MockToken("Token2", "TK2", 18);  
        token3 = new MockToken("Token3", "TK3", 18);
        
        // 设置ETF参数
        tokens.push(address(token1));
        tokens.push(address(token2));
        tokens.push(address(token3));
        
        amounts.push(1e18);
        amounts.push(1e18);
        amounts.push(1e18);
        
        // 部署ETF合约
        etf = new ETFv1("Test ETF", "TETF", tokens, amounts, 1e15);
        
        // 给测试账户铸造代币
        token1.mint(address(this), 100e18);
        token2.mint(address(this), 100e18);
        token3.mint(address(this), 100e18);
    }
    
    function testMint() public {
        // 批准代币转账
        token1.approve(address(etf), 1e18);
        token2.approve(address(etf), 1e18);
        token3.approve(address(etf), 1e18);
        
        // 记录投资前余额
        uint256 balanceBefore = etf.balanceOf(address(this));
        
        // 投资ETF
        etf.mint(amounts);
        
        // 验证ETF代币余额增加
        uint256 balanceAfter = etf.balanceOf(address(this));
        assertGt(balanceAfter, balanceBefore);
    }
    
    function testRedeem() public {
        // 先投资
        testMint();
        
        uint256 shares = etf.balanceOf(address(this));
        uint256 token1Before = token1.balanceOf(address(this));
        
        // 赎回
        etf.redeem(shares);
        
        // 验证代币余额恢复
        uint256 token1After = token1.balanceOf(address(this));
        assertGt(token1After, token1Before);
    }
}
```

### 运行测试
```bash
# 运行所有测试
forge test

# 运行特定测试
forge test --match-test testMint

# 详细输出
forge test -vvv

# 生成测试覆盖率报告
forge coverage
```

## 🚨 安全注意事项

### 1. 授权检查
```javascript
// 检查代币授权额度
async function checkAllowance(tokenAddress, ownerAddress, spenderAddress) {
    const token = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
    const allowance = await token.allowance(ownerAddress, spenderAddress);
    return allowance;
}
```

### 2. 滑点保护
```javascript
// 计算最小输出（考虑滑点）
function calculateMinOutput(expectedOutput, slippageBPS) {
    const slippageFactor = (10000 - slippageBPS) / 10000;
    return expectedOutput * slippageFactor;
}
```

### 3. 交易状态检查
```javascript
// 检查交易状态
async function waitForConfirmation(txHash, confirmations = 1) {
    const receipt = await provider.waitForTransaction(txHash, confirmations);
    if (receipt.status === 0) {
        throw new Error('交易失败');
    }
    return receipt;
}
```

## 📈 监控和分析

### 获取ETF表现数据
```javascript
// 获取ETF净值
async function getETFNetValue() {
    const totalSupply = await etf.totalSupply();
    if (totalSupply.eq(0)) return 0;
    
    const tokens = await etf.getTokens();
    const amounts = await etf.getTokenAmounts();
    
    let totalValue = 0;
    for (let i = 0; i < tokens.length; i++) {
        const tokenPrice = await getTokenPrice(tokens[i]); // 需要实现价格获取
        const tokenValue = amounts[i] * tokenPrice;
        totalValue += tokenValue;
    }
    
    return totalValue / ethers.formatEther(totalSupply);
}

// 获取用户收益率
async function getUserReturn(userAddress) {
    const userBalance = await etf.balanceOf(userAddress);
    const currentValue = userBalance * await getETFNetValue();
    const investedValue = await getUserInvestedValue(userAddress); // 需要追踪
    
    return (currentValue - investedValue) / investedValue * 100;
}
```

---

**文档最后更新**: 2025年9月23日  
**合约部署网络**: Sepolia Testnet  
**支持的交互方式**: JavaScript, Python, Foundry, Cast