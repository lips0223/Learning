# ETFåˆçº¦äº¤äº’æŒ‡å—

## ğŸ¯ å¿«é€Ÿå¼€å§‹

### ç¯å¢ƒå‡†å¤‡
```bash
# 1. å…‹éš†é¡¹ç›®
git clone <repository_url>
cd contracts

# 2. å®‰è£…ä¾èµ–
forge install

# 3. è®¾ç½®ç¯å¢ƒå˜é‡
export PRIVATE_KEY="your_private_key"
export SEPOLIA_RPC_URL="https://sepolia.infura.io/v3/your_project_id"
```

## ğŸ“ åˆçº¦ABIæ¥å£

### ETFv1 æ ¸å¿ƒæ¥å£
```solidity
interface IETF {
    // é“¸é€ ETFä»£å¸
    function mint(uint256[] calldata amounts) external;
    
    // èµå›ETFä»£å¸
    function redeem(uint256 shares) external;
    
    // æŸ¥è¯¢æˆåˆ†ä»£å¸
    function getTokens() external view returns (address[] memory);
    
    // æŸ¥è¯¢æ¯ä»½é¢å¯¹åº”çš„ä»£å¸æ•°é‡
    function getTokenAmounts() external view returns (uint256[] memory);
    
    // æŸ¥è¯¢æœ€å°é“¸é€ æ•°é‡
    function minMintAmount() external view returns (uint256);
}
```

### ETFv2 å¢å¼ºæ¥å£
```solidity
interface IETFv2 {
    // ETHæŠ•èµ„
    function investWithETH() external payable;
    
    // ETHèµå›
    function redeemToETH(uint256 shares) external;
    
    // æŸ¥è¯¢Uniswapè·¯ç”±
    function swapRouter() external view returns (address);
}
```

## ğŸ”§ JavaScriptäº¤äº’ç¤ºä¾‹

### è¿æ¥åˆçº¦
```javascript
const { ethers } = require('ethers');

// è¿æ¥åˆ°Sepoliaç½‘ç»œ
const provider = new ethers.JsonRpcProvider('https://sepolia.infura.io/v3/your_project_id');
const wallet = new ethers.Wallet('your_private_key', provider);

// ETFv1åˆçº¦å®ä¾‹
const ETFv1_ADDRESS = '0x37Ee135db8e41D3F9C15F97918C58651E8A564A6';
const ETFv1_ABI = [...]; // ä»ç¼–è¯‘ç»“æœè·å–ABI
const etfv1 = new ethers.Contract(ETFv1_ADDRESS, ETFv1_ABI, wallet);
```

### ETFv1 äº¤äº’
```javascript
// 1. æŸ¥è¯¢åˆçº¦ä¿¡æ¯
async function getETFInfo() {
    const name = await etfv1.name();
    const symbol = await etfv1.symbol();
    const tokens = await etfv1.getTokens();
    const amounts = await etfv1.getTokenAmounts();
    
    console.log(`ETF: ${name} (${symbol})`);
    console.log('æˆåˆ†ä»£å¸:', tokens);
    console.log('ä»£å¸æ•°é‡:', amounts.map(a => ethers.formatEther(a)));
}

// 2. æŠ•èµ„ETF
async function investETF() {
    const tokenAddresses = await etfv1.getTokens();
    const tokenAmounts = await etfv1.getTokenAmounts();
    
    // æ‰¹å‡†ä»£å¸è½¬è´¦
    for (let i = 0; i < tokenAddresses.length; i++) {
        const token = new ethers.Contract(tokenAddresses[i], ERC20_ABI, wallet);
        const approveTx = await token.approve(ETFv1_ADDRESS, tokenAmounts[i]);
        await approveTx.wait();
        console.log(`å·²æ‰¹å‡† ${tokenAddresses[i]} è½¬è´¦`);
    }
    
    // é“¸é€ ETF
    const mintTx = await etfv1.mint(tokenAmounts);
    const receipt = await mintTx.wait();
    console.log('æŠ•èµ„æˆåŠŸ:', receipt.transactionHash);
}

// 3. èµå›ETF
async function redeemETF(shares) {
    const redeemTx = await etfv1.redeem(ethers.parseEther(shares));
    const receipt = await redeemTx.wait();
    console.log('èµå›æˆåŠŸ:', receipt.transactionHash);
}
```

### ETFv2 ETHæŠ•èµ„
```javascript
const ETFv2_ADDRESS = '0xe75dDeb4d90F62b0D70CAFe2c8db9B968E29336c';
const etfv2 = new ethers.Contract(ETFv2_ADDRESS, ETFv2_ABI, wallet);

// ETHæŠ•èµ„
async function investWithETH() {
    const investAmount = ethers.parseEther('0.1'); // 0.1 ETH
    
    const tx = await etfv2.investWithETH({
        value: investAmount
    });
    
    const receipt = await tx.wait();
    console.log('ETHæŠ•èµ„æˆåŠŸ:', receipt.transactionHash);
}

// ETHèµå›
async function redeemToETH(shares) {
    const tx = await etfv2.redeemToETH(ethers.parseEther(shares));
    const receipt = await tx.wait();
    console.log('ETHèµå›æˆåŠŸ:', receipt.transactionHash);
}
```

## ğŸ Pythonäº¤äº’ç¤ºä¾‹

### ç¯å¢ƒè®¾ç½®
```python
from web3 import Web3
import json

# è¿æ¥åˆ°Sepoliaç½‘ç»œ
w3 = Web3(Web3.HTTPProvider('https://sepolia.infura.io/v3/your_project_id'))

# è®¾ç½®è´¦æˆ·
account = w3.eth.account.from_key('your_private_key')
w3.eth.default_account = account.address

# åˆçº¦åœ°å€å’ŒABI
ETF_V1_ADDRESS = '0x37Ee135db8e41D3F9C15F97918C58651E8A564A6'
with open('out/ETFv1.sol/ETFv1.json', 'r') as f:
    contract_json = json.load(f)
    ETF_ABI = contract_json['abi']

# åˆ›å»ºåˆçº¦å®ä¾‹
etf_contract = w3.eth.contract(address=ETF_V1_ADDRESS, abi=ETF_ABI)
```

### åˆçº¦äº¤äº’
```python
# æŸ¥è¯¢åˆçº¦ä¿¡æ¯
def get_etf_info():
    name = etf_contract.functions.name().call()
    symbol = etf_contract.functions.symbol().call()
    tokens = etf_contract.functions.getTokens().call()
    amounts = etf_contract.functions.getTokenAmounts().call()
    
    print(f"ETF: {name} ({symbol})")
    print(f"æˆåˆ†ä»£å¸: {tokens}")
    print(f"ä»£å¸æ•°é‡: {[Web3.from_wei(amt, 'ether') for amt in amounts]}")

# æŠ•èµ„ETF
def invest_etf():
    tokens = etf_contract.functions.getTokens().call()
    amounts = etf_contract.functions.getTokenAmounts().call()
    
    # æ‰¹å‡†ä»£å¸è½¬è´¦
    erc20_abi = [...]  # ERC20 ABI
    for i, token_addr in enumerate(tokens):
        token_contract = w3.eth.contract(address=token_addr, abi=erc20_abi)
        
        # æ„å»ºäº¤æ˜“
        approve_txn = token_contract.functions.approve(
            ETF_V1_ADDRESS, amounts[i]
        ).build_transaction({
            'from': account.address,
            'nonce': w3.eth.get_transaction_count(account.address),
            'gas': 100000,
            'gasPrice': w3.to_wei('20', 'gwei')
        })
        
        # ç­¾åå¹¶å‘é€
        signed_approve = w3.eth.account.sign_transaction(approve_txn, account.key)
        approve_hash = w3.eth.send_raw_transaction(signed_approve.rawTransaction)
        w3.eth.wait_for_transaction_receipt(approve_hash)
        print(f"å·²æ‰¹å‡†ä»£å¸ {token_addr}")
    
    # é“¸é€ ETF
    mint_txn = etf_contract.functions.mint(amounts).build_transaction({
        'from': account.address,
        'nonce': w3.eth.get_transaction_count(account.address),
        'gas': 500000,
        'gasPrice': w3.to_wei('20', 'gwei')
    })
    
    signed_mint = w3.eth.account.sign_transaction(mint_txn, account.key)
    mint_hash = w3.eth.send_raw_transaction(signed_mint.rawTransaction)
    receipt = w3.eth.wait_for_transaction_receipt(mint_hash)
    print(f"æŠ•èµ„æˆåŠŸ: {receipt.transactionHash.hex()}")
```

## ğŸ“Š äº‹ä»¶ç›‘å¬

### JavaScriptäº‹ä»¶ç›‘å¬
```javascript
// ç›‘å¬é“¸é€ äº‹ä»¶
etfv1.on('Transfer', (from, to, value) => {
    if (from === ethers.ZeroAddress) {
        console.log(`æ–°é“¸é€ : ${ethers.formatEther(value)} ETF ä»£å¸ç»™ ${to}`);
    }
});

// ç›‘å¬æŠ•èµ„äº‹ä»¶
etfv1.on('Invested', (user, amounts, shares) => {
    console.log(`ç”¨æˆ· ${user} æŠ•èµ„äº†:`);
    amounts.forEach((amt, i) => {
        console.log(`  ä»£å¸${i}: ${ethers.formatEther(amt)}`);
    });
    console.log(`è·å¾—ä»½é¢: ${ethers.formatEther(shares)}`);
});
```

### Pythonäº‹ä»¶ç›‘å¬
```python
# ç›‘å¬æ–°åŒºå—ä¸­çš„äº‹ä»¶
def watch_events():
    # åˆ›å»ºäº‹ä»¶è¿‡æ»¤å™¨
    event_filter = etf_contract.events.Invested.create_filter(fromBlock='latest')
    
    while True:
        for event in event_filter.get_new_entries():
            print(f"æŠ•èµ„äº‹ä»¶: {event}")
            print(f"ç”¨æˆ·: {event.args.user}")
            print(f"æŠ•èµ„é‡‘é¢: {[Web3.from_wei(amt, 'ether') for amt in event.args.amounts]}")
            print(f"è·å¾—ä»½é¢: {Web3.from_wei(event.args.shares, 'ether')}")
        
        time.sleep(2)  # æ¯2ç§’æ£€æŸ¥ä¸€æ¬¡
```

## ğŸ§ª å•å…ƒæµ‹è¯•ç¤ºä¾‹

### Foundryæµ‹è¯•
```solidity
// test/ETFv1.t.sol
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "../src/ETFv1/ETFv1.sol";
import "../src/MockToken/MockToken.sol";

contract ETFv1Test is Test {
    ETFv1 public etf;
    MockToken public token1;
    MockToken public token2;
    MockToken public token3;
    
    address[] public tokens;
    uint256[] public amounts;
    
    function setUp() public {
        // éƒ¨ç½²æµ‹è¯•ä»£å¸
        token1 = new MockToken("Token1", "TK1", 18);
        token2 = new MockToken("Token2", "TK2", 18);  
        token3 = new MockToken("Token3", "TK3", 18);
        
        // è®¾ç½®ETFå‚æ•°
        tokens.push(address(token1));
        tokens.push(address(token2));
        tokens.push(address(token3));
        
        amounts.push(1e18);
        amounts.push(1e18);
        amounts.push(1e18);
        
        // éƒ¨ç½²ETFåˆçº¦
        etf = new ETFv1("Test ETF", "TETF", tokens, amounts, 1e15);
        
        // ç»™æµ‹è¯•è´¦æˆ·é“¸é€ ä»£å¸
        token1.mint(address(this), 100e18);
        token2.mint(address(this), 100e18);
        token3.mint(address(this), 100e18);
    }
    
    function testMint() public {
        // æ‰¹å‡†ä»£å¸è½¬è´¦
        token1.approve(address(etf), 1e18);
        token2.approve(address(etf), 1e18);
        token3.approve(address(etf), 1e18);
        
        // è®°å½•æŠ•èµ„å‰ä½™é¢
        uint256 balanceBefore = etf.balanceOf(address(this));
        
        // æŠ•èµ„ETF
        etf.mint(amounts);
        
        // éªŒè¯ETFä»£å¸ä½™é¢å¢åŠ 
        uint256 balanceAfter = etf.balanceOf(address(this));
        assertGt(balanceAfter, balanceBefore);
    }
    
    function testRedeem() public {
        // å…ˆæŠ•èµ„
        testMint();
        
        uint256 shares = etf.balanceOf(address(this));
        uint256 token1Before = token1.balanceOf(address(this));
        
        // èµå›
        etf.redeem(shares);
        
        // éªŒè¯ä»£å¸ä½™é¢æ¢å¤
        uint256 token1After = token1.balanceOf(address(this));
        assertGt(token1After, token1Before);
    }
}
```

### è¿è¡Œæµ‹è¯•
```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
forge test

# è¿è¡Œç‰¹å®šæµ‹è¯•
forge test --match-test testMint

# è¯¦ç»†è¾“å‡º
forge test -vvv

# ç”Ÿæˆæµ‹è¯•è¦†ç›–ç‡æŠ¥å‘Š
forge coverage
```

## ğŸš¨ å®‰å…¨æ³¨æ„äº‹é¡¹

### 1. æˆæƒæ£€æŸ¥
```javascript
// æ£€æŸ¥ä»£å¸æˆæƒé¢åº¦
async function checkAllowance(tokenAddress, ownerAddress, spenderAddress) {
    const token = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
    const allowance = await token.allowance(ownerAddress, spenderAddress);
    return allowance;
}
```

### 2. æ»‘ç‚¹ä¿æŠ¤
```javascript
// è®¡ç®—æœ€å°è¾“å‡ºï¼ˆè€ƒè™‘æ»‘ç‚¹ï¼‰
function calculateMinOutput(expectedOutput, slippageBPS) {
    const slippageFactor = (10000 - slippageBPS) / 10000;
    return expectedOutput * slippageFactor;
}
```

### 3. äº¤æ˜“çŠ¶æ€æ£€æŸ¥
```javascript
// æ£€æŸ¥äº¤æ˜“çŠ¶æ€
async function waitForConfirmation(txHash, confirmations = 1) {
    const receipt = await provider.waitForTransaction(txHash, confirmations);
    if (receipt.status === 0) {
        throw new Error('äº¤æ˜“å¤±è´¥');
    }
    return receipt;
}
```

## ğŸ“ˆ ç›‘æ§å’Œåˆ†æ

### è·å–ETFè¡¨ç°æ•°æ®
```javascript
// è·å–ETFå‡€å€¼
async function getETFNetValue() {
    const totalSupply = await etf.totalSupply();
    if (totalSupply.eq(0)) return 0;
    
    const tokens = await etf.getTokens();
    const amounts = await etf.getTokenAmounts();
    
    let totalValue = 0;
    for (let i = 0; i < tokens.length; i++) {
        const tokenPrice = await getTokenPrice(tokens[i]); // éœ€è¦å®ç°ä»·æ ¼è·å–
        const tokenValue = amounts[i] * tokenPrice;
        totalValue += tokenValue;
    }
    
    return totalValue / ethers.formatEther(totalSupply);
}

// è·å–ç”¨æˆ·æ”¶ç›Šç‡
async function getUserReturn(userAddress) {
    const userBalance = await etf.balanceOf(userAddress);
    const currentValue = userBalance * await getETFNetValue();
    const investedValue = await getUserInvestedValue(userAddress); // éœ€è¦è¿½è¸ª
    
    return (currentValue - investedValue) / investedValue * 100;
}
```

---

**æ–‡æ¡£æœ€åæ›´æ–°**: 2025å¹´9æœˆ23æ—¥  
**åˆçº¦éƒ¨ç½²ç½‘ç»œ**: Sepolia Testnet  
**æ”¯æŒçš„äº¤äº’æ–¹å¼**: JavaScript, Python, Foundry, Cast